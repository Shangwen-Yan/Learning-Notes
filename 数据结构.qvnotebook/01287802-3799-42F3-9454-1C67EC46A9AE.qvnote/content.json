{
  "title": "七、排序（上）",
  "cells": [
    {
      "type": "markdown",
      "data": "7.1. 格式：void X\\_Sort(ElementType A[], intN) \n\n* X：排序名称\n* 讨论从小到大的整数排序\n* N是正整数\n* 只讨论继续比较的排序（\\>=\\<有定义）\n* 只讨论内部排序（所有数据的排序在内存空间中一次完成）\n* 稳定性：保证任意两个相等的数据，排序前后相对位置不变\n* 没有一种排序是任何情况下都表现最好的\n\n7.2. 冒泡排序：Bubble\\_Sort() \n\n* 比较相邻两数据，前大后小则交换，指针一次+1\n* 一次排序之后，最大的冒到最后一个\n* 最后一部分的数据总是有序的\n* 代码：\n\n```\nfor(P=N-1;P\\>=0;P--){ \n\n  flag=0; \n  \n  for(i=0;i\\<P;i++){ \n  \n  if(A[i]\\>A[i+1]){ //判断写\\>不写\\>=，保证稳定性 \n  \n  Swap(); \n  \n  flag++} \n\n} \n\nif(flag==0) break； //全程无交换 \n```\n* 时间复杂度T=： \n\n  * 最好：O(N)\n  * 最坏：O(N^2) N+(N-1)+(N-2)+....+1\n\n7.3.插入排序：Insertion\\_Sort() \n\n* 从前往后摸牌\n* 在摸过的牌中，从后往前比较，大则放在最后，小则往前找到合适的位置插入\n* 前面摸过的牌总是有序的\n* 代码： \n\n  for(P=1;P\\<N;P++){ //默认第一张牌已经摸过 \n\n  Tmp=A[P]; //摸下一张牌 \n\n  for(i=P;i\\>0 && A[i-1]\\>Tmp);i--){ //判断写\\>不写\\>=，保证稳定性 \n\n  A[i]=A[i-1]； //移出空位 \n\n  } \n\n  A[i]=Tmp; //新牌落位  \n\n  }\n* 时间复杂度T= \n\n  * 最好：O(N)\n  * 最坏：O(N^2)\n\n7.4.时间复杂度下界 \n\n* 逆序对inversion：对于i\\<j,若A[I]\\>A[J]，则称(i,j)是一对逆序对\n* 插入排序：T(N,I)=O(N+I)\n* 定理：N个不同元素的序列平均具有N(N-1)/4个逆序对(I)\n* 定理：任何仅以交换两相邻元素来排序的算法，平均时间复杂度为Ω(N^2) \n\n  * →想提高算法效率，每次要消去不止一个逆序对\n  * 每次交换相隔较远的两个元素\n\n7.5.希尔排序---by Donald Shell \n\n* 定义希尔增量序列：Dm\\>Dm-1\\>...\\>D1=1\n* 对每个Dk进行Dk间隔排序\n* 每次间隔排序不会打乱前一次的间隔排序\n* 原始希尔排序： \n\n  * Dm=[N/2]，之后每次都除二取下整数\n  * 代码： \n\n    ```\n    void Shell_sort(ElementType A[],int N){ \n      for(D=N/2;D>0;D/=2){ \n        for(P=D;P<N;P++){ //P+D??? \n          Tmp=A[P]; \n          for(i=P;i\\>=D&&A[i-D]>Tmp;i-=D){ \n            A[i]=A[i-D] \n          } \n        A[i]=Tmp \n        } \n      } \n    }\n    ```\n  * 最坏情况：$T=θ(N^2)$  \n\n    * 希尔增量不互质导致\n    * D=1之前都没有交换\n\n7.6.堆排序"
    }
  ]
}